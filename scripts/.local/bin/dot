#!/bin/sh
# Dotfiles management CLI
set -e

DOTFILES="${DOTFILES:-$HOME/dotfiles}"

# shellcheck source=../../../install/lib.sh
. "$DOTFILES/install/lib.sh"

cmd_update() {
    cd "$DOTFILES"
    [ "$1" != "--no-pull" ] && {
        git diff-index --quiet HEAD -- 2>/dev/null || { echo "Uncommitted changes. Continue? [y/N]"; read -r a; [ "$a" != "y" ] && exit 1; }
        log "Pulling..."; git pull --rebase
    }
    log "Suckless..."
    # Parallel compilation
    pids=""
    for d in dwm dmenu dwmblocks; do
        [ -d "$DOTFILES/$d" ] && {
            { make -C "$DOTFILES/$d" clean >/dev/null 2>&1 || true; sudo make -C "$DOTFILES/$d" install >/dev/null; } &
            pids="$pids $!"
        }
    done
    for pid in $pids; do wait "$pid" || true; done
    pgrep -x dwm >/dev/null && pkill -HUP dwm
    pgrep -x dwmblocks >/dev/null && { killall dwmblocks; dwmblocks & }
    if [ -n "$DISPLAY" ]; then
        xrdb -I"$HOME/.local/share" -merge "$HOME/.config/x11/xresources" 2>/dev/null || true
    fi
    log "Done!"
}

cmd_link() {
    log "Linking..."

    # Copy defaults to XDG_DATA_HOME (decouples runtime from repo)
    log "Copying defaults..."
    target="${XDG_DATA_HOME:-$HOME/.local/share}/dotfiles"
    case "$target" in */dotfiles) ;; *) echo "Safety check failed: $target"; exit 1 ;; esac
    rm -rf "$target"
    cp -r "$DOTFILES/default" "$target"

    # Clone private fonts repo if not present
    if [ ! -d "$DOTFILES/fonts/.git" ]; then
        log "Cloning private fonts..."
        rm -rf "$DOTFILES/fonts"
        FONTS_REPO="${FONTS_REPO:-git@github.com:theseifhassan/fonts.git}"
        git clone "$FONTS_REPO" "$DOTFILES/fonts" 2>/dev/null || {
            log "Could not clone fonts (private repo - need SSH key)"
            mkdir -p "$DOTFILES/fonts"
        }
    fi

    # Install fonts if present
    if [ -d "$DOTFILES/fonts" ] && find "$DOTFILES/fonts" -maxdepth 1 -type f \( -name "*.ttf" -o -name "*.otf" \) 2>/dev/null | grep -q .; then
        log "Installing fonts..."
        mkdir -p "${XDG_DATA_HOME:-$HOME/.local/share}/fonts"
        find "$DOTFILES/fonts" -maxdepth 1 -type f \( -name "*.ttf" -o -name "*.otf" \) -exec cp {} "${XDG_DATA_HOME:-$HOME/.local/share}/fonts/" \;
        fc-cache -f
    fi

    # Install TPM if not present (shallow clone)
    TPM_DIR="${XDG_DATA_HOME:-$HOME/.local/share}/tmux/plugins/tpm"
    if [ ! -d "$TPM_DIR" ]; then
        log "Installing TPM..."
        git clone --depth 1 https://github.com/tmux-plugins/tpm "$TPM_DIR"
    fi

    link_configs

    systemctl --user daemon-reload
    log "Done!"
}

cmd_packages() {
    PKGFILE="$DOTFILES/install/packages"
    [ ! -f "$PKGFILE" ] && { echo "install/packages not found"; exit 1; }
    [ "$1" = "-d" ] || [ "$1" = "--diff" ] && {
        log "Missing:"
        while IFS= read -r p || [ -n "$p" ]; do case "$p" in \#*|"") continue;; esac; pacman -Qi "$p" >/dev/null 2>&1 || echo "  $p"; done < "$PKGFILE"
        exit 0
    }
    log "Installing..."
    grep -vE "^\s*#|^\s*$" "$PKGFILE" | xargs paru -S --needed --noconfirm
}

cmd_suckless() {
    t="${1:-all}"; log "Building $t..."
    if [ "$t" = "all" ]; then
        # Parallel compilation
        pids=""
        for d in dwm dmenu dwmblocks; do
            [ -d "$DOTFILES/$d" ] && {
                sudo make -C "$DOTFILES/$d" clean install &
                pids="$pids $!"
            }
        done
        for pid in $pids; do wait "$pid" || true; done
    else
        [ -d "$DOTFILES/$t" ] && sudo make -C "$DOTFILES/$t" clean install
    fi
    pgrep -x dwm >/dev/null && pkill -HUP dwm
    pgrep -x dwmblocks >/dev/null && { killall dwmblocks; dwmblocks & }
}

cmd_hardware() { "$DOTFILES/install/hardware.sh" "$@"; }
cmd_install() { "$DOTFILES/install/setup.sh"; }

cmd_tools() {
    command -v mise >/dev/null 2>&1 || {
        log "Installing mise..."
        curl https://mise.run | sh
        export PATH="$HOME/.local/bin:$PATH"
    }

    case "${1:-}" in
        install|"")
            log "Installing tools via mise..."
            mise install
            ;;
        upgrade)
            log "Upgrading tools..."
            mise upgrade
            ;;
        list)
            mise list
            ;;
        outdated)
            mise outdated
            ;;
        *)
            cat <<EOF
dot tools <cmd>
  install     Install all tools from mise config (default)
  upgrade     Upgrade all tools to latest
  list        List installed tools
  outdated    Show outdated tools
EOF
            ;;
    esac
}

cmd_wallpaper() {
    WALLPAPER_DIR="${WALLPAPER_DIR:-$HOME/Pictures/Wallpapers}"
    STATE_FILE="${XDG_STATE_HOME:-$HOME/.local/state}/wallpaper_index"
    
    [ ! -d "$WALLPAPER_DIR" ] && { echo "Wallpaper dir not found: $WALLPAPER_DIR"; exit 1; }
    
    # Get sorted list of wallpapers
    wallpapers=$(find -L "$WALLPAPER_DIR" -type f \( -iname "*.png" -o -iname "*.jpg" -o -iname "*.jpeg" \) | sort)
    count=$(echo "$wallpapers" | grep -c . || echo 0)
    [ "$count" -eq 0 ] && { echo "No wallpapers found"; exit 1; }
    
    # Get current wallpaper from feh state
    current=""
    [ -f "$HOME/.fehbg" ] && current=$(sed -n "s/.*'\([^']*\)'[^']*$/\1/p" "$HOME/.fehbg" 2>/dev/null || true)

    # Find current index
    idx=0
    if [ -n "$current" ]; then
        i=0
        while IFS= read -r w; do
            [ "$w" = "$current" ] && { idx=$i; break; }
            i=$((i + 1))
        done <<EOF
$wallpapers
EOF
    fi
    
    set_wallpaper() {
        wp=$(echo "$wallpapers" | sed -n "$((${1} + 1))p")
        [ -n "$wp" ] && { feh --bg-fill "$wp"; echo "$1" > "$STATE_FILE"; echo "Set: $(basename "$wp")"; }
    }
    
    case "${1:-}" in
        next)
            new_idx=$(( (idx + 1) % count ))
            set_wallpaper "$new_idx"
            ;;
        prev)
            new_idx=$(( (idx - 1 + count) % count ))
            set_wallpaper "$new_idx"
            ;;
        random)
            new_idx=$(shuf -i 0-$((count - 1)) -n 1)
            set_wallpaper "$new_idx"
            ;;
        current|status)
            [ -n "$current" ] && echo "Current: $(basename "$current")" || echo "No wallpaper set"
            echo "Total: $count wallpapers"
            ;;
        list)
            echo "$wallpapers" | while IFS= read -r w; do
                [ "$w" = "$current" ] && echo "* $(basename "$w")" || echo "  $(basename "$w")"
            done
            ;;
        *)
            cat <<EOF
dot wallpaper <cmd>
  next      Next wallpaper in sequence
  prev      Previous wallpaper
  random    Random wallpaper
  current   Show current wallpaper
  list      List all wallpapers (* = current)
EOF
            ;;
    esac
}

cmd_monitor() {
    case "${1:-}" in
        save)
            [ -z "${2:-}" ] && { echo "Usage: dot monitor save <name>"; exit 1; }
            autorandr --save "$2"
            echo "Profile '$2' saved. Use 'dot monitor switch $2' to load it."
            ;;
        switch|load)
            [ -z "${2:-}" ] && { echo "Usage: dot monitor switch <name>"; exit 1; }
            autorandr --load "$2" --force
            ;;
        list)
            autorandr
            ;;
        *)
            cat <<EOF
dot monitor <cmd>
  save <name>    Save current display config as profile
  switch <name>  Switch to a saved profile
  list           List available profiles

Setup guide:
  1. With laptop screen only:  dot monitor save laptop
  2. With external monitor:    dot monitor save docked
  Profiles auto-switch when displays connect/disconnect.
EOF
            ;;
    esac
}

cmd_help() { cat <<EOF
dot <cmd> [args]
  update [--no-pull]  Pull, recompile, reload
  link                Symlink configs
  packages [-d]       Install packages (-d: show missing)
  tools <cmd>         Manage dev tools via mise (install|upgrade|list|outdated)
  suckless [target]   Recompile dwm/dmenu/dwmblocks
  hardware <cmd>      Install: nvidia|bluetooth|printer|fingerprint|virtualcam|all
                      nvidia disable - Disable GPU for max battery
                      Verify: check [device]
  monitor <cmd>       Manage display profiles (save|switch|list)
  wallpaper <cmd>     Cycle wallpapers (next|prev|random|current|list)
  install             Full setup
EOF
}

[ "${SOURCED:-}" = "1" ] && return 0 2>/dev/null || true

case "${1:-}" in
    update) shift; cmd_update "$@" ;;
    link) cmd_link ;;
    packages) shift; cmd_packages "$@" ;;
    tools) shift; cmd_tools "$@" ;;
    suckless) shift; cmd_suckless "$@" ;;
    hardware) shift; cmd_hardware "$@" ;;
    monitor) shift; cmd_monitor "$@" ;;
    wallpaper|wp) shift; cmd_wallpaper "$@" ;;
    install) cmd_install ;;
    -h|--help|help) cmd_help ;;
    *) cmd_help ;;
esac
